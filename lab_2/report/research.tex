\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программы, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:
\begin{itemize}[label={---}]
	\item операционная система: Windows 11, x64;
	\item оперативная память: 8 Гб;
	\item процессор: AMD Ryzen 5 5500U с видеокартой Radeon Graphics 2.10~ГГц.
\end{itemize}

Во время замеров времени ноутбук был нагружен только встроенными приложениями окружения.

\section{Демонстрация работы программы}

На рисунках~\ref{img:run1}~--- \ref{img:run3} представлен результат работы программы.

\inputPdf{run1}{Пример работы программы (часть 1)}
\inputPdf{run2}{Пример работы программы (часть 2)}
\inputPdf{run3}{Пример работы программы (часть 3)}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени process\_time из библиотеки time на Python. Функция возвращает пользовательское процессорное время типа float.

Использовать функцию приходится дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры проводились для размеров матриц от 10 до 100 с шагом 10 по 100 раз на различных входных данных, а также для нечетных размеров --- от 11 до 101 с шагом 10 по 100 раз.

Результаты замеров приведены в таблицах~\ref{tbl:time_mes_even},~\ref{tbl:time_mes_noteven} (время в мс).

\begin{landscape}
\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright, singlelinecheck=off}
			\caption{Результаты замеров времени для четных размеров матриц}
			\label{tbl:time_mes_even}
			\begin{tabular}{|c|c|c|c|}
				\hline
				Размер матрицы & Классический алгоритм & Алгоритм Винограда & Опт. алгоритм Винограда\\
				\hline
				10&0.266&0.219&0.125\\
				\hline
				20&1.719&0.625&0.938\\
				\hline
				30&5.469&5.0&3.125\\
				\hline
				40&12.656&10.938&7.031\\
				\hline
				50&22.031&20.0&17.031\\
				\hline
				60&27.344&34.688&26.562\\
				\hline
				70&47.969&52.5&40.625\\
				\hline
				80&69.219&74.844&65.312\\
				\hline
				90&107.031&112.812&89.375\\
				\hline
				100&138.125&153.281&124.688\\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright, singlelinecheck=off}
			\caption{Результаты замеров времени для нечетных размеров матриц}
			\label{tbl:time_mes_noteven}
			\begin{tabular}{|c|c|c|c|}
				\hline
				Размер матрицы & Классический алгоритм & Алгоритм Винограда & Опт. алгоритм Винограда\\
				\hline
				11&0.312&0.203&0.188\\
				\hline
				21&1.875&1.406&1.094\\
				\hline
				31&3.594&4.531&3.594\\
				\hline
				41&9.375&10.781&10.0\\
				\hline
				51&19.375&21.406&17.812\\
				\hline
				61&32.5&36.094&28.594\\
				\hline
				71&49.688&55.938&44.219\\
				\hline
				81&72.969&84.531&68.594\\
				\hline
				91&108.125&116.406&94.219\\
				\hline
				101&139.375&164.062&132.656\\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}
\end{landscape}

На рисунках~\ref{img:graphEven},~\ref{img:graphNotEven} приведена визуализация результатов замеров.

\inputPdf{graphEven}{Визуализация результатов замеров для четных размеров матриц}

\inputPdf{graphNotEven}{Визуализация результатов замеров для нечетных размеров матриц}

\section{Вывод}

В результате эксперимента было получено, что при четных размерах матриц реализация классического алгоритма умножения матриц работает быстрее алгоритма Винограда при размерах матриц больше $[50\times 50]$. При нечетных размерах --- при размерах больше $[21 \times 21]$. 