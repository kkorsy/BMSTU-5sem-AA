\chapter{Аналитическая часть}

В данном разделе будут рассмотрены алгоритмы нахождения расстояния Левенштейна и Дамерау --- Левенштейна.

\section{Расстояние Левенштейна}

\textbf{Расстояние Левенштейна} между двумя строками --- минимальное количество редакционных операций вставки, удаления, замены, необходимых для превращения одной строки в другую~\cite{dlbook}.
Были введены следующие обозначения:
\begin{itemize}[label={---}]
	\item I (aнгл. Insert) --- вставка символа в произвольной позиции;
	\item D (aнгл. Delete) --- удаление символа в произвольной позиции;
	\item R (aнгл. Replace) --- замена символа на другой;
	\item M (aнгл. Match) --- совпадение двух символов.
\end{itemize} 

Пусть исходная строка --- $S_{1}$, целевая --- $S_{2}$.
$S_{1}[1\dots i]$ --- подстрока $S_{1}$ длиной $i$ символов, начиная с начального.
$S_{2}[1\dots j]$ --- подстрока $S_{2}$ длиной $j$ символов, начиная с начального.
Пусть $L_{1}$ --- длина строки $S_{1}$, $L_{2}$ --- длина строки $S_{2}$.


С учетом введенных обозначений, расстояние Левенштейна было подсчитано по следующей рекуррентной формуле:


\begin{equation}
	\label{eq:D}
	D(S_{1}[1\dots i], \\
	S_{2}[1\dots j]) = \begin{cases}
		
		0, i = 0, j = 0\\
		i, j = 0, i > 0\\
		j, i = 0, j > 0\\
		\min \lbrace \\
		\qquad D(S_{1}[1\dots i], S_{2}[1\dots j-1]) + 1\\
		\qquad D(S_{1}[1\dots i-1], S_{2}[1\dots j]) + 1,\\
		\qquad D(S_{1}[1\dots i-1], S_{2}[1\dots j-1]) + \\
		\quad\quad +\begin{cases}
			0, S_{1}[i] == S_{2}[j]\\
			1, иначе
			\end{cases}\\
		\rbrace, i > 0, j > 0
	\end{cases}
\end{equation}

\section{Расстояние Дамерау --- Левенштейна}

Дамерау ввел четвертую операцию --- транспозицию соседних символов со штрафом 1. Обозначение --- X (англ. Exchange). Следовательно, расстояние Дамерау --- Левенштейна --- это минимальное количество редакционных операций вставки, удаления, замены, обмена, необходимых для превращения одной строки в другую.

Расстояние Дамерау --- Левенштейна считается по рекурсивной формуле~(\ref{eq:DL}).

\begin{equation}
	\label{eq:DL}
	D(S_{1}[1\dots i], S_{2}[1\dots j]) = \begin{cases}
		
		0, i = 0, j = 0\\
		i, j = 0, i > 0\\
		j, i = 0, j > 0\\
		\min \lbrace \\
		\qquad D(S_{1}[1\dots i], S_{2}[1\dots j-1]) + 1\\
		\qquad D(S_{1}[1\dots i-1], S_{2}[1\dots j]) + 1 \\
		\qquad D(S_{1}[1\dots i-2], S_{2}[1\dots j-2]) + 1,\\
		\quad\quad\quad\quad S_{1}[i] == S_{2}[j-1], \\
		\quad\quad\quad\quad S_{1}[i-1] == S_{2}[j]\\
		\qquad D(S_{1}[1\dots i-1], S_{2}[1\dots j-1]) + \\
		\qquad\qquad +\begin{cases}
			0, S_{1}[i] == S_{2}[j]\\
			1, иначе
		\end{cases}\\
		\rbrace
	\end{cases}
\end{equation}

\section{Нерекурсивный алгоритм нахождения расстояния Левенштейна}

Идея алгоритма: заполнять матрицу не от конца к началу, как при рекурсивных алгоритмах, а наоборот, от начала к концу.

Создается матрица с числом строк $(L_{1}+1)$ и числом столбцов $(L_{2}+1)$. Так как первый столбец и первая строка соответствуют пустым строкам, то в полученной матрице они заполняются тривиально. Затем каждый элемент $A[i;j]$ матрицы вычисляется на основе элементов $A[i-1;j]$, $A[i;j-1]$,~$A[i-1;j-1]$ по следующей формуле:

\begin{equation}
	\begin{aligned}
		A[i;j] = \min\lbrace &\\
		& A[i-1;j] + 1\\
		& A[i;j-1] + 1\\
		& A[i-1;j-1] + \begin{cases}
			0, S_{1}[i] == S_{2}[j]\\
			1, иначе\\
		\end{cases}\\
		&\rbrace, i > 0, j > 0
	\end{aligned}
\end{equation}
После заполнения всей матрицы результатом будет являться элемент $A[L_{1};L_{2}]$.

Возможной оптимизацией данного алгоритма является минимизация используемой памяти. Поскольку для вычисления текущего элемента матрицы необходимы только 2 строки: текущая и предыдущая, то можно хранить не всю матрицу, а только последние 2 строки.

\section{Нерекурсивный алгоритм нахождения расстояния Дамерау --- Левенштейна}
Идея алгоритма аналогична идее нахождения расстояния Левенштейна. Однако в случае нахождения расстояния Дамерау --- Левенштейна каждый элемент $A[i;j]$ матрицы вычисляется на основе элементов $A[i-1;j]$, $A[i;j-1]$, $A[i-1;j-1]$, $A[i-2; j-2]$ по следующей формуле:

\begin{equation}
	\begin{aligned}
		A[i;j] = \min\lbrace &\\
		& A[i-1;j] + 1\\
		& A[i;j-1] + 1\\
		& A[i-2;j-2] + 1, S_{1}[i] == S_{2}[j-1], S_{1}[i-1] == S_{2}[j]\\
		& A[i-1;j-1] + \begin{cases}
			0, S_{1}[i] == S_{2}[j]\\
			1, иначе\\
		\end{cases}\\
		&\rbrace, i > 0, j > 0
	\end{aligned}
\end{equation}

Аналогично, возможна минимизация используемой памяти: хранение не всей матрицы, а только последних трех строк.

\section{Рекурсивный алгоритм нахождения расстояния Дамерау --- Левенштейна}
Рекурсивный алгоритм вычисления расстояния Дамерау --- Левенштейна реализует формулу~(\ref{eq:DL}).

Основной проблемой данного алгоритма являются повторные вычисления. В качестве оптимизации можно хранить кэш в виде матрицы.

\section{Рекурсивный алгоритм нахождения расстояния Дамерау --- Левенштейна с использованием кэша}

В качестве оптимизации рекурсивного алгоритма заполнения можно использовать кэш, который будет представлять собой матрицу.
Суть оптимизации --- при выполнении рекурсии происходит
заполнение матрицы.

Изначально матрица заполнена бесконечно большими числами. Если рекурсивный алгоритм выполняет прогон для данных, которые еще
не были обработаны, то результат нахождения заносится в матрицу. Иначе, если обработанные данные встречаются снова, то для них расстояние не
находится и алгоритм переходит к следующему шагу.

\section*{Вывод}

В данном разделе было дано математическое описание расстояний Левенштейна
и Дамерау --- Левенштейна, которые являются рекуррентными, что позволяет
реализовать их как рекурсивно, так и итерационно.

К разрабатываемой программе предъявляются следующие требования:
\begin{enumerate}
\item Программа должна предоставлять функциональность раcчета расстояния Левенштейна матричным и оптимизированным матричным алгоритмами, а также расстояния Дамерау --- Левенштейна рекурсивным, рекурсивным с кэшем, матричным и оптимизированным матричным алгоритмами.

\item Реализуемое ПО будет работать в двух режимах --- пользовательском, в
котором можно выбрать алгоритм и вывести для него рассчитанное значение,
а также экспериментальном режим, в котором можно произвести сравнение реализаций алгоритмов по времени работы на различных входных данных.

\item В первом режиме в качестве входных данных в программу будет подаваться две строки, также реализовано меню для вызова алгоритмов и замеров времени. Ограничением для работы программного продукта является то, что программе на вход может подаваться строка на английском или русском языке, а также программа должна корректно обрабатывать случай ввода пустых строк.
\item Во втором режиме будет происходить измерение процессорного времени работы программы, будут построены зависимости времени расстояний от совпадающих длин входных строк. Входные строки будут сгенерированы автоматически для заданной совпадающей длины строк.
\end{enumerate}


