\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программы, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:
\begin{itemize}[label={---}]
	\item операционная система: Windows 11, x64 \cite{w11};
	\item оперативная память: 8 Гб;
	\item процессор: AMD Ryzen 5 5500U с видеокартой Radeon Graphics 2.10~ГГц.
\end{itemize}

Во время замеров времени ноутбук был нагружен только встроенными приложениями окружения.

\section{Демонстрация работы программы}

На рисунке \ref{img:run} представлен результат работы программы.

\inputSvg{run}{Пример работы программы}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени \textit{process\_time} из библиотеки \textit{time} на \textit{Python}. Функция возвращает пользовательское процессорное время типа \textit{float}.

Использовать функцию приходится дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры проводились для длины слова от 10 до 410 с шагом 50 по 100 раз на различных входных данных.

Результаты замеров приведены в таблице \ref{tbl:time_mes} (время в мс). Используются следующие обозначения:
\begin{itemize}[label=---]
	\item Д.-Л.(матр.) --- матричный алгоритм нахождения расстояния Дамерау --- Левенштейна;
	\item Л.(матр.) --- матричный алгоритм нахождения расстояния Левенштейна;
	\item Д.-Л.(опт.) --- оптимизированный матричный алгоритм нахождения расстояния Дамерау --- Левенштейна;
	\item Л.(опт.) --- оптимизированный матричный алгоритм нахождения расстояния Левенштейна;
	\item Д.-Л.(кэш) --- рекурсивный алгоритм нахождения расстояния Дамерау --- Левенштейна с использованием кэша в виде матрицы.
\end{itemize}

\begin{table}[H]
	\begin{center}
			\captionsetup{justification=raggedright, singlelinecheck=off}
			\caption{Результаты замеров времени}
			\label{tbl:time_mes}
			\begin{tabular}{|c|c|c|c|c|c|}
				\hline
				Длина & \thead{Д.-Л.(матр.),\\мс} & \thead{Л.(матр.),\\мс} & \thead{Д.-Л.(опт.),\\мс} & \thead{Л.(опт.),\\мс} & \thead{Д.-Л.(кэш),\\мс}\\
				\hline
				10 & 0.0588 & 0.0550 & 0.0503 & 0.0397 & 0.1522 \\ 
				\hline
				60 & 2.0313 & 1.7813 & 1.7188 & 1.2969 & 5.0781 \\ 
				\hline
				110 & 6.3750 & 5.9218 & 6.0313 & 4.1250 & 18.8125 \\ 
				\hline
				160 & 13.7500 & 10.9375 & 13.5938 & 7.6563 & 41.2500 \\ 
				\hline
				210 & 24.3750 & 18.7500 & 22.6563 & 16.7188 & 67.9688 \\ 
				\hline
				260 & 36.7188 & 25.9375 & 32.0313 & 24.2188 & 104.3750 \\ 
				\hline
				310 & 56.5625 & 40.6250 & 47.1875 & 35.6250 & 150.6250 \\ 
				\hline
				360 & 76.7188 & 61.0938 & 61.4063 & 49.5313 & 211.8750 \\ 
				\hline
				410 & 100.3125 & 78.7500 & 83.9063 & 60.3125 & 273.5938 \\ 
				\hline			
			\end{tabular}
	\end{center}
\end{table}

На рисунке \ref{img:graphs} приведена визуализация результатов замеров.

\begin{figure}[H]
	\center{\includesvg[inkscapelatex=false,width=0.9\textwidth]{graphs}}
	\caption{Визуализация результатов замеров}
	\label{img:graphs}
\end{figure}

\section{Вывод}

Исходя из оценки памяти, итеративные алгоритмы проигрывают рекурсивным, потому что максимальный размер памяти в них растет, как произведение длин строк, а в рекурсивных - как сумма длин строк.

В результате эксперимента было получено, что наибольшее время работы программы получается при использовании рекурсивных алгоритмов. Исходя из замеров по времени, реализация оптимизированного матричного алгоритма нахождения расстояния Левенштейна при больших длинах строк работает быстрее остальных реализаций. 