\chapter{Аналитическая часть}
В данном разделе будет рассмотрена конвейерная обработка, а также алгоритмы Кнута~---~Морриса~---~Пратта и Бойера~---~Мура.

\section{Конвейерная обработка}

Конвейер --- это механизм, предназначенный для распараллеливания выполнения команд программы между блоками процессора. Он позволяет загрузить блоки процессора при выполнении команд оптимально, без простоев \cite{conv}. Заявка --- структура с временем и флагом отбоя.

Генератор заранее генерирует $N$ заявок и помещает их в первую очередь. Из первой очереди обслуживающее устройство 1 берет заявку и выполняет первую стадию обработки, после чего помещает ее во вторую очередь. Из второй очереди берет заявку обслуживающее устройство 2. И так далее. В результате последнее обслуживающее устройство помещает заявку в пул обработанных заявок. Когда все заявки будут обработаны (конвейер завершит свою работу), по пулу будет сформирована статистика и выведена в лог-файл. При этом каждый рабочий поток существует, пока не получит специальную заявку с установленным флагом отбоя.

Поскольку очереди заявок являются разделяемой памятью, для обеспечения монопольного доступа к ним необходимо использовать мьютекс. Мьютексы представляют собой объекты ядра, используемые для синхронизации, регулирующие доступ к единственному ресурсу \cite{mutex}.

В данной работе обслуживающее устройство 1 выполняет поиск подстроки в файле по алгоритму Кнута~---~Морриса~---~Пратта. Обслуживающее устройство 2 --- по алгоритму Бойера~---~Мура. Обслуживающее устройство 3 выполняет запись результатов поиска в файл.

\section{Алгоритм Кнута~---~Морриса~---~Пратта}

Алгоритм Кнута~---~Морриса~---~Пратта используется для поиска специальных подстрок с повторами префиксов \cite{kmp}. Его основная идея --- построение автомата для определения величин смещения. При смещении подстроки после $n$ успешных сравнений и 1 неуспешного считается, что одно сравнение префикса в активе и его не нужно проверять.

Рассмотрим пример. Пусть искомая подстрока --- $ababcb$. В построенном автомате состояния маркируются проверяемым в нем символом, дугу --- успехом ($s$) или неудачей ($f$). Полученный автомат представлен на рисунке~\ref{img:auto}.

\inputPdf{auto}{Автомат для определения величин смещения}

В результате будет получен массив сдвигов, который рассчитывается один раз и используется повторно. Для примера выше таким массивом будет:~$[1, 1, 2, 2, 2, 5]$

\section{Алгоритм Бойера~---~Мура}

Преимущество этого алгоритма в том, что необходимо сделать некоторые предварительные вычисления над подстрокой, чтобы сравнение подстроки с исходной строкой осуществлять не во всех позициях --- часть проверок пропускаются как заведомо не дающие результата \cite{bm}. 

Первоначально строится таблица смещений для искомой подстроки. Далее идет совмещение начала строки и подстроки и начинается проверка с последнего символа подстроки. 
Если последний символ подстроки и соответствующий ему при наложении символ строки не совпадают, подстрока сдвигается относительно строки на величину, полученную из таблицы смещений, и снова проводится сравнение, начиная с последнего символа подстроки. 
Если же символы совпадают, производится сравнение предпоследнего символа подстроки и так далее. 
Если все символы подстроки совпали с наложенными символами строки, значит, найдена подстрока и поиск окончен. 
Если же какой-то (не последний) символ подстроки не совпадает с соответствующим символом строки, далее производим сдвиг подстроки на один символ вправо и снова выполняется проверка с последнего символа. 
Весь алгоритм выполняется до тех пор, пока либо не будет найдено вхождение искомой подстроки, либо не будет достигнут конец строки. 
Величина сдвига в случае несовпадения последнего символа вычисляется, исходя из следующего: сдвиг подстроки должен быть минимальным, таким, чтобы не пропустить вхождение подстроки в строке. 
Если данный символ строки встречается в подстроке, то подстрока смещается таким образом, чтобы символ строки совпал с самым правым вхождением этого символа в подстроке. 
Если же подстрока вообще не содержит этого символа, то подстрока сдвигается на величину, равную ее длине, так что первый символ подстроки накладывается на следующий за проверявшимся символом строки.

Величина смещения для каждого символа подстроки зависит только от порядка символов в подстроке, поэтому смещения удобно вычислить заранее и хранить в виде одномерного массива, где каждому символу алфавита соответствует смещение относительно последнего символа подстроки.

\section{Вывод}

В данном разделе была теоретически разобрана конвейерная обработка, а также алгоритмы Кнута~---~Морриса~---~Пратта и Бойера~---~Мура.

К разрабатываемой программе предъявляются следующие требования:
\begin{enumerate}
	\item Программа должна предоставлять функциональность конвейерной обработки;
	
	\item Реализуемое ПО будет работать в двух режимах --- пользовательском, в котором можно выбрать алгоритм и вывести для него результат, а также экспериментальном режиме, в котором можно произвести сравнение времени обработки в зависимости от количества заявок на различных входных данных;
	
	\item В первом режиме в качестве входных данных в программу будет подаваться текстовые файлы, также реализовано меню для вызова конвейерной обработки и замеров времени;
	
	\item Во втором режиме будет происходить измерение процессорного времени, будут построены зависимости времени обработки всех заявок от их количества. Заявки будут сгенерированы автоматически для заданного размера искомых подстрок.
\end{enumerate}